\section{Системные вызовы}

Самый простой способ (но не единственный) организовать системные вызовы в x86
это использовать прерывания. Для этого вам необходимо проделать несколько простых
шагов. О каждом подробнее далее.

\subsection{Дескриптор прерывания в IDT}

Первая и самая простая часть - завести дескриптор \emph{IDT} для нашего будущего
системного вызова. Вы можете выбрать любую неиспользуемую запись \emph{IDT} для
этого.

Дескриптор системного вызова почти совпадает с дескриптором обычного прерывания,
с той лишь разницей, что значение поля \emph{DPL} должно быть равно 3, в противном
случае системный вызов будет приводить к \emph{Genral Protection Error}.

Кроме этого, обычно, на время выполнения системного вызова не нужно выключать
прерывания, поэтому для системных вызовов зачастую используют \emph{trap gate}
вместо \emph{interrupt gate}.

\subsection{Обработчик системного вызова}

Естественно, вы должны также предоставить обработчик прерывания, который по
параметрам системного вызова разберется, чего от него хочет пространство
пользователя. Поэтому вам нужно продумать возможность передавать параметры в
системный вызов, а также уметь возвращать из него значение (например, если
вы реализуете системный вызов \emph{fork}).

Самый простой способ передавать параметры в системный вызов - использовать
регистры. Например, вы можете зафиксировать за регистром \emph{RAX} номер
прерывания, по которому ядро узнает, какой именно системный вызов запросило
пространство пользователя, а в регистре \emph{RBX} передавать указатель на
структуру, которая описывает параметры системного вызова.

Конкретный интерфейс остается на ваше усмотрение, но важно, чтобы система не
падала, если из пространства пользователя придет неверный номер системного
вызова (проверка параметров, по хорошему тоже нужна, но она не так тривиальна,
как кажется на первый взгляд) - в этом случае вы должны вернуть какой-то признак
ошибки. Самый простой способ возвращать значения из системного вызова - регистры.

Соответственно, в вашем приложении, которое будет запущено в пространстве пользователя
должна быть функция, которая знает как и в каком виде нужно передавать параметры
в системный вызов, и как получать результат.

\subsection{Task State Struct}

Структура состояния задачи в 64-битном режиме выглядит довольно просто, она содержит
указатели стека для всех уровней привилегий кроме низшего, остальные поля нас не
интересуют и их можно заполнить нулями. Формат можно посмотреть в разделе
7.7 TASK MANAGEMENT IN 64-BIT MODE документации Intel.

Мы собираемся использовать только два уровня привилегий - 0 и 3. Поэтому нас на
самом дере интересует только одно поле этой структуры - запись соответствующая
указателю стека ядра. В эту запись мы, скорее всего, хотим записать вершину
стека ядра выделенного при создании потока. Т. е. при системном вызове в \emph{RSP}
запишется указатель вершины стека, который вы алоцировали для вашего потока при
создании.

При переключении потоков, нам достаточно поменять это поле внутри \emph{TSS} и
больше никаких действий касающихся \emph{TSS} при переключении потоков производить
не требуется.

\subsection{Запись TSS в GDT}

Для нашего \emph{TSS} в \emph{GDT} требуется завести дескриптор, этот дескриптор,
должен хранить адрес и размер нашей \emph{TSS}, а также некоторые служебные поля,
которые нам не интересны, но заполнить их все равно придется.

Если вы пользуетесь предоставленным вам кодом, то определение \emph{GDT} находится
в файле \emph{bootstrap.S}, вы можете убедиться, что там зарезервированы записи в
конце таблицы как раз под \emph{TSS}.

Все, что вам нужно это получить указатель на эту таблицу и заполнить соответствующую
запись нужными данными. Чтобы получить указатель на \emph{GDT} используйте функцию
\emph{get\_gdt\_ptr} из файла \emph{memory.h}.

Теперь касательно полей, которые вам нужно заполнить. Формат дескриптора вы можете,
опять же найти в документации в разделе 7.2.3 TSS Descriptor in 64-bit mode. Частью
жтого формата является тип записи. Все возможные типы перечислены в разделе 3.5
SYSTEM DESCRIPTOR TYPES все той же документации Intel - найти нужный не состаит
труда.

В качестве значений \emph{Base} и \emph{Limit} используйте виртуальный адрес
\emph{TSS} и и ее размер минус единица, бит гранулярности, соответственно, должен
быть сброшен, так как размер указывается в байтах.

Наконец в качестве значения \emph{DPL} нужно указать наименьший уровень привилегий,
т. е. 3.

После того, как вы заполнили запись нужными значениями, вам необходимо загрузить
селектор этой записи в регистр \emph{TR}, для этого воспользуйтесь функцией
\emph{load\_tr} из файла \emph{memory.h} (хотя эта функция относится скорее к
потокам, чем к памяти). На этом все мучения с \emph{TSS} заканчиваются, вам остается
лишь подменять одно поле в \emph{TSS} при переключении потоков.
