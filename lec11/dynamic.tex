\begin{frame}
\frametitle{Динамическая компоновка}
\begin{itemize}
  \item<1-> Библиотеки, упрощенно, разделяют на статические и динамические:
    \begin{itemize}
      \item статические библиотеки компонуются вместе с исполняемым файлом;
      \item динамические библиотеки не являются частью исполняемого файла, а загружаются по требованию;
    \end{itemize}
  \item<2-> Зачем нужны динамические библиотеки:
    \begin{itemize}
      \item не нужно дублировать один и тот же код между множеством исполняемых файлов;
      \item можно избежать дублирования одного и того же кода в памяти загрузив его в единственном экземпляре;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Динамическая компоновка}
\begin{itemize}
  \item<1-> Динамическая библиотека может быть загружена по любому адресу
    \begin{itemize}
      \item исполняемый файл не может заранее знать, по какому адресу находятся функции и данные библиотеки;
      \item библиотека сама не знает по какому адресу находятся ее функции и данные;
    \end{itemize}
  \item<2-> Таким образом нужно решить несколько задач:
    \begin{itemize}
      \item загрузить все необходимые динамические библиотеки в память;
      \item сообщить приложению адреса нужных функций и данных;
      \item сделать так, что библиотека могла быть загружена и работать по любому адресу;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Динамический компоновщик}
\begin{itemize}
  \item<1-> В \emph{ELF} файле может быть специальный \emph{Program Header} с типом \emph{PT\_INTERP} (значение 3)
    \begin{itemize}
      \item этот заголовок описывает участок файла где хранится строка;
      \item эта строка - путь к динамическому компоновщику;
      \item ОС загружает динамический компоновщик вместе с исполняемым файлом и передает ему управление;
    \end{itemize}
  \item<2-> Динамический компоновщик должен найти и загрузить нужные библиотеки:
    \begin{itemize}
      \item информация о динамических библиотеках хранится в \emph{Program Header} с типом \emph{PT\_DYNAMIC};
      \item но ОС это не волнует - дальше всю работу делает динамический компоновщик;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Обращение к данным}
\begin{itemize}
  \item<1-> Программа (или динамическая библиотека) может не знать где хранятся нужные данные до загрузки
    \begin{itemize}
      \item для разрешения проблемы используется \emph{Global Offset Table (GOT)};
      \item внешним переменным сопоставляются записи в \emph{GOT};
      \item динамический компоновщик знает адрес \emph{GOT} и заполняет ее правильными значениями;
      \item код программы (библиотеки) тоже должен найти \emph{GOT} для этого используется относительная адресация;
    \end{itemize}
  \item<2-> Относительная адресация:
    \begin{itemize}
      \item мы можем не знать адрес \emph{GOT};
      \item но мы можем знать, что она находится на определенном смещении от исполняемого кода;
      \item возьмем указатель команд \emph{RIP} (для x86) и прибавим к нему смещение;
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Вызов функций}
\begin{itemize}
  \item<1-> Как и сданными, программа (или библиотека) может не знать адреса функции до загрузки
    \begin{itemize}
      \item компоновщик (не динамический), создает таблицу \emph{Procedure Linkage Table (PLT)};
      \item каждая запись в \emph{PLT} это переход по адресу записанному в \emph{GOT};
    \end{itemize}
  \item<2-> Ленивое разрешение имен:
    \begin{itemize}
      \item динамический компоновщик не обязан заполнять все записи в \emph{GOT} соответствующие функциям;
      \item можно организовать так, чтобы при вызове функции вызывался динамический компоновщик;
      \item тогда можно разрешать имена и загружать библиотеки только, если к ним было обращение;
    \end{itemize}
\end{itemize}
\end{frame}
